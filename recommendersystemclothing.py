# -*- coding: utf-8 -*-
"""RecommenderSystemCLothing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XqvFpZUikTbXHUEVRfqcRTgPRSCEhBdD
"""

import numpy as np
import seaborn as sns
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler  
import os
import json

df = pd.read_csv("styles.csv", nrows=5000, error_bad_lines=False)
df['image'] = df.apply(lambda row: str(row['id']) + ".jpg", axis=1)
df.head(10)

print(df.shape)

import cv2
from google.colab.patches import cv2_imshow # For showing jpg files directly

def show_img(img):
  cv2_imshow(load_image(img))

def img_path(img):
  return DATASET_PATH+"/images/"+img;

def load_image(img):
  img = cv2.imread((img_path(img)))
  return img

for i, row in df.sample(5).iterrows():
  print("im "+str(i))
  show_img(row.image)

plt.figure(figsize=(20,20))
df.masterCategory.value_counts().plot(kind='bar',color='y')
plt.figure(figsize=(20,20))
df.articleType.value_counts().plot(kind='bar',color='b')

import tensorflow as tf
import keras
from keras.applications.resnet50 import ResNet50
from keras.applications.resnet50 import preprocess_input
from keras.layers import GlobalMaxPooling2D

load_image(df['image'][0]).shape

img_width, img_height, _ = 80, 60, 3 

base_model = ResNet50(weights='imagenet', 
                      include_top=False, 
                      input_shape = (img_width, img_height, 3))
base_model.trainable = False

model = keras.Sequential([
    base_model,
    GlobalMaxPooling2D()
])

model.summary()

def get_embedding(model, img_name):
  img=image.load_img(img_path(img_name),target_size=(img_width,img_height))
  x=image.img_to_array(img)
  x=np.expand_dims(x,axis=0)
  x= preprocess_input(x)
  return model.predict(x).reshape(-1)

emb=get_embedding(model,df['image'][0]);

df_emb=df['image'].apply(lambda img :get_embedding(model, img))
df_emb.head()

df_emb=df_emb.apply(pd.Series)
df_emb.head()

df.head()

from sklearn.metrics.pairwise import pairwise_distances
cosine_sim = 1-pairwise_distances(df_emb,metric='cosine')

cosine_sim[:5]

cosine_sim.shape

def get_rec_images(index_chosen,num_rec=5):
  m=cosine_sim.shape[0]
  cosine_sim_chosen=cosine_sim[index_chosen]
  indexes=[x for x in range(m)]
  cosine_sim_chosen[index_chosen]=0;
  zipped=zip(cosine_sim_chosen,indexes)
  sorted_zip=sorted(zipped,reverse=True)
  indexes=[ind for _,ind in sorted_zip]
  return indexes[:num_rec]

##########################################################################################3
index_chosen=4000;                                                                        #change index for changing image
num_rec=5;                                                                                #no of recommended images
##########################################################################################3

print("Image chosen by you is shown below:")
show_img(df['image'][index_chosen])
indexes=get_rec_images(index_chosen,num_rec)
print("Recommended images to you:")
for i in range(num_rec):
  show_img(df['image'][indexes[i]])


